/**
 * ç”¢ç”Ÿé—œæ–¼ç¼ºå¤±è²¢ç»è€…çš„äººé¡å¯è®€å ±å‘Šã€‚
 * æ­¤æ¨¡çµ„é€é 'gh' æŸ¥è©¢å·²åˆä½µçš„ PR ä¸¦ç”¢ç”Ÿ markdown å ±å‘Šã€‚
 */
import { execSync } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { setupGracefulShutdown } from './utils/graceful-shutdown.mjs';

const DEFAULT_CMD_TIMEOUT = 30_000; // 30 ç§’

setupGracefulShutdown('contributor-report');

/**
 * ä»£è¡¨è‡ªå‹•ç”¢ç”Ÿæª”æ¡ˆçš„æ¨¡å¼ï¼›è²¢ç»è€…ä¸æ‡‰å› é€™äº›æª”æ¡ˆè€Œç²å¾—ç©åˆ†ï¼Œ
 * å› ç‚ºå®ƒå€‘ä¸å±¬æ–¼å¯¦è³ªæ€§çš„æ’°å¯«å…§å®¹ã€‚
 */
export const AUTO_GENERATED_PATTERNS = [
  'README.md',
  'README.*.md',
  'collections/*.md',
  'collections/*.collection.md',
  'docs/README.*.md',
  'docs/*.generated.md'
];

/**
 * ç”¨æ–¼å¾æª”æ¡ˆè·¯å¾‘æ¨æ–·è²¢ç»é¡å‹çš„æª”æ¡ˆè¬ç”¨å­—å…ƒ (globs)ã€‚
 */
export const TYPE_PATTERNS = {
  instructions: [
    'instructions/*.instructions.md'
  ],
  prompts: [
    'prompts/*.prompt.md'
  ],
  agents: [
    'chatmodes/*.chatmode.md',
    'agents/*.agent.md'
  ],
  skills: [
    'skills/'
  ],
  collections: [
    'collections/*.collection.yml'
  ],
  doc: [
    'docs/**/*.md',
    '.github/**/*.md',
    'CONTRIBUTING.md',
    'SECURITY.md',
    'SUPPORT.md',
    'LICENSE.md',
    'CHANGELOG.md',
    '*.md'
  ],
  infra: [
    '.github/workflows/**/*.yml',
    '.github/workflows/**/*.yaml',
    '**/*.yml',
    '**/*.yaml'
  ],
  maintenance: [
    'package*.json',
    '*config*',
    'tsconfig*.json'
  ],
  code: [
    '**/*.js',
    '**/*.ts',
    '**/*.mjs',
    '**/*.cjs',
    '**/*.py'
  ]
};

const globCache = new Map();

/**
 * å°‡ç°¡å–®çš„ glob (åŒ…å« *, **) è½‰æ›ç‚º RegExpã€‚
 * é‡å°æœ¬å„²å­˜åº«çš„æ¨¡å¼ï¼Œæ­¤è¨­è¨ˆåˆ»æ„ä¿æŒå°å‹ä¸”å…·å‚™ç¢ºå®šæ€§ã€‚
 * @param {string} pattern
 * @returns {RegExp}
 */
export const globToRegExp = (pattern) => {
  const DOUBLE_WILDCARD_PLACEHOLDER = 'Â§Â§DOUBLEÂ§Â§';

  // è½‰ç¾©é™¤äº† glob è¬ç”¨å­—å…ƒ (*, ?, /) ä»¥å¤–çš„æ‰€æœ‰ regex ç‰¹æ®Šå­—å…ƒï¼Œ
  // ç„¶å¾Œå°‡ glob èªæ³•ç¿»è­¯ç‚º regexã€‚
  // æ³¨æ„ï¼šæ­¤å‡½å¼åˆ»æ„åƒ…æ”¯æ´ glob èªæ³•çš„å­é›†ã€‚
  const regexSpecials = /[.+^${}()|[\]\\]/g;

  let normalized = String(pattern);

  // å°‡ Windows é¢¨æ ¼çš„åˆ†éš”ç¬¦è™Ÿæ­£è¦åŒ–ç‚º POSIX é¢¨æ ¼ä»¥ä¾¿åŒ¹é…ã€‚
  normalized = normalized.replaceAll('\\', '/');

  // è½‰ç¾© regex ä¸­ç¹¼å­—å…ƒï¼Œä½¿å…¶è¢«è¦–ç‚ºå¸¸å€¼ã€‚
  normalized = normalized.replaceAll(regexSpecials, (match) => `\\${match}`);

  // è™•ç† glob è¬ç”¨å­—å…ƒã€‚
  normalized = normalized.replaceAll('**', DOUBLE_WILDCARD_PLACEHOLDER);
  normalized = normalized.replaceAll('*', '[^/]*');
  normalized = normalized.replaceAll(DOUBLE_WILDCARD_PLACEHOLDER, '.*');
  normalized = normalized.replaceAll('?', '.');

  return new RegExp(`^${normalized}$`);
};

/**
 * æ¸¬è©¦æª”æ¡ˆè·¯å¾‘æ˜¯å¦ç¬¦åˆ glob æ¨¡å¼ã€‚
 * @param {string} filePath
 * @param {string} pattern
 * @returns {boolean}
 */
export const matchGlob = (filePath, pattern) => {
  if (!globCache.has(pattern)) {
    try {
      globCache.set(pattern, globToRegExp(pattern));
    } catch {
      globCache.set(pattern, null);
    }
  }

  const regexp = globCache.get(pattern);
  if (!regexp) {
    return false;
  }

  const normalized = filePath.replaceAll('\\', '/');
  return regexp.test(normalized);
};

/**
 * å¦‚æœæŒ‡å®šè·¯å¾‘ç¬¦åˆå·²çŸ¥çš„è‡ªå‹•ç”¢ç”Ÿæ¨¡å¼ï¼Œå‰‡å‚³å› trueã€‚
 * @param {string} filePath
 * @returns {boolean}
 */
export const isAutoGeneratedFile = (filePath) => {
  return AUTO_GENERATED_PATTERNS.some((pattern) => matchGlob(filePath, pattern));
};

/**
 * ç‚ºæª”æ¡ˆè·¯å¾‘æ¨æ–·è²¢ç»é¡å‹å­—ä¸² (ä¾‹å¦‚ 'prompts'ã€'agents'ã€'doc')ã€‚
 * å¦‚æœæ²’æœ‰åŒ¹é…çš„ç‰¹å®šé¡å‹ï¼Œå‰‡å‚³å› nullã€‚
 * @param {string} filePath
 * @returns {string|null}
 */
export const getFileContributionType = (filePath) => {
  const normalized = filePath.replaceAll('\\', '/');

  for (const [type, patterns] of Object.entries(TYPE_PATTERNS)) {
    if (patterns.some((pattern) => matchGlob(normalized, pattern))) {
      return type;
    }
  }

  return null;
};

/**
 * å¾æª”æ¡ˆæ¸…å–®ä¸­è¡ç”Ÿä»¥é€—è™Ÿåˆ†éš”çš„è²¢ç»é¡å‹è­˜åˆ¥ç¢¼æ¸…å–®ã€‚
 * æœƒå¿½ç•¥è‡ªå‹•ç”¢ç”Ÿçš„æª”æ¡ˆã€‚è‹¥ç„¡æª”æ¡ˆå¯è™•ç†ï¼Œå‰‡å‚³å› ''ã€‚
 * @param {string[]} files
 * @returns {string}
 */
export const getContributionTypes = (files) => {
  const types = new Set();
  let processed = 0;

  for (const file of files) {
    if (isAutoGeneratedFile(file)) {
      continue;
    }

    processed += 1;
    const type = getFileContributionType(file);
    if (type) {
      types.add(type);
    }
  }

  if (processed === 0) {
    return '';
  }

  if (types.size === 0) {
    types.add('code');
  }

  return Array.from(types).sort((a, b) => a.localeCompare(b)).join(',');
};

/**
 * æª¢æŸ¥ .all-contributors è¼¸å‡ºä»¥æ¢ç´¢ç¼ºå¤±çš„è²¢ç»è€…ã€‚
 * é€™æ˜¯è²¢ç»è€…å·¥å…·ä½¿ç”¨çš„æ¬Šå¨å¯¦ä½œæ–¹å¼ã€‚
 * @returns {string[]}
 */
export const getMissingContributors = () => {
  try {
    console.log('ğŸ” æ­£åœ¨æª¢æŸ¥ç¼ºå¤±çš„è²¢ç»è€…...');

    const configPath = path.join(process.cwd(), '.all-contributorsrc');
    const config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    const ignoreEntries = config.ignoreList || config.ignore || [];
    const ignoreSet = new Set(ignoreEntries.map((entry) => entry.toLowerCase()));

    if (ignoreSet.size > 0) {
      console.log(`ğŸ“‹ å·²è¼‰å…¥å¿½ç•¥æ¸…å–®: ${Array.from(ignoreSet).join(', ')}`);
    }

    const output = execSync('npx all-contributors check', {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe'],
      timeout: DEFAULT_CMD_TIMEOUT
    });

    const lines = output.split('\n');

    const headerLineIndex = lines.findIndex(line =>
      line.includes('Missing contributors in .all-contributorsrc:')
    );

    if (headerLineIndex === -1) {
      console.log('âœ… æœªæ‰¾åˆ°ç¼ºå¤±çš„è²¢ç»è€…');
      return [];
    }

    let contributorsLine = '';
    for (let i = headerLineIndex + 1; i < lines.length; i++) {
      const line = lines[i].trim();

      if (line.includes('Unknown contributors') || line.includes('âœ¨')) {
        break;
      }

      if (line && !line.startsWith('â ™') && !line.startsWith('âœ¨')) {
        contributorsLine = line;
        break;
      }
    }

    if (!contributorsLine) {
      console.log('âœ… æœªæ‰¾åˆ°ç¼ºå¤±çš„è²¢ç»è€…');
      return [];
    }

    const allUsernames = contributorsLine
      .split(',')
      .map(username => username.trim())
      .filter(username => username.length > 0);

    const filteredUsernames = allUsernames.filter(username => {
      const lowerUsername = username.toLowerCase();

      if (ignoreSet.has(lowerUsername)) {
        console.log(`â­ï¸  å·²éæ¿¾: ${username} ä½æ–¼å¿½ç•¥æ¸…å–®ä¸­`);
        return false;
      }

      return true;
    });

    console.log(`ğŸ“‹ éæ¿¾å¾Œæ‰¾åˆ° ${filteredUsernames.length} ä½ç¼ºå¤±çš„è²¢ç»è€…: ${filteredUsernames.join(', ')}`);
    return filteredUsernames;

  } catch (error) {
    const stderr = String(error?.stderr ?? '');
    const stdout = String(error?.stdout ?? '');
    const details = [stderr, stdout, String(error?.message ?? '')].join('\n');

    // çµ•å°ä¸è¦åˆ—å°æ¬Šæ–å€¼ã€‚åƒ…åˆ—å°å¯è¡Œçš„æŒ‡å°èªªæ˜ã€‚
    if (details.toLowerCase().includes('bad credentials') || details.includes('401')) {
      console.error('âŒ all-contributors é©—è­‰å¤±æ•— (æ†‘è­‰éŒ¯èª¤ / 401)ã€‚');
      console.error('ğŸ’¡ è«‹åœ¨ PRIVATE_TOKEN (all-contributors-cli) å’Œ/æˆ– GH_TOKEN (gh CLI) ä¸­è¨­å®šæœ‰æ•ˆçš„æ¬Šæ–ã€‚');
      console.error('ğŸ’¡ åœ¨ GitHub Actions ä¸­ï¼Œé€šå¸¸å¯ä»¥ä½¿ç”¨ï¼šsecrets.GITHUB_TOKEN');
      throw new Error('ç”±æ–¼æ†‘è­‰ç„¡æ•ˆï¼Œcontributors:check å¤±æ•—');
    }

    console.error('âŒ æª¢æŸ¥ç¼ºå¤±è²¢ç»è€…æ™‚ç™¼ç”ŸéŒ¯èª¤:', String(error?.message ?? error));
    if (details.trim()) {
      console.error('--- all-contributors è¼¸å‡º (å·²æˆªæ–·) ---');
      console.error(details.slice(0, 2000));
      console.error('--- è¼¸å‡ºçµæŸ ---');
    }

    if (String(error?.message ?? '').includes('command not found') || String(error?.message ?? '').includes('not recognized')) {
      console.error('ğŸ’¡ è«‹ç¢ºä¿å·²å®‰è£ all-contributors-cliï¼šnpm install all-contributors-cli');
    }

    throw error;
  }
};

// --- å ±å‘Šç”¢ç”Ÿé‚è¼¯ ---

/**
 * ä»¥ owner/repo æ ¼å¼ç²å–ç•¶å‰çš„ GitHub å„²å­˜åº«ã€‚
 * å„ªå…ˆå˜—è©¦ upstreamï¼Œç„¶å¾Œæ˜¯ originã€‚
 * @returns {string}
 */
const getGitHubRepo = () => {
  const parseRepoFromRemoteUrl = (remoteUrl) => {
    const url = String(remoteUrl || '').trim();
    if (!url) return null;

    // æ”¯æ´æ ¼å¼ï¼š
    // - git@github.com:owner/repo.git
    // - ssh://git@github.com/owner/repo.git
    // - https://github.com/owner/repo.git
    // - https://github.com/owner/repo
    const regex = /github\.com[/:]([^/]+)\/([^/?#]+?)(?:\.git)?(?:[/?#]|$)/;
    const match = regex.exec(url);
    if (!match) return null;

    return `${match[1]}/${match[2]}`;
  };

  try {
    const upstreamUrl = execSync('git config --get remote.upstream.url', {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();
    if (upstreamUrl) {
      const repo = parseRepoFromRemoteUrl(upstreamUrl);
      if (repo) return repo;
    }
  } catch (e) {
    console.debug('æ‰¾ä¸åˆ° upstreamï¼Œæ­£åœ¨å˜—è©¦ origin', e?.message || e);
  }

  try {
    const originUrl = execSync('git config --get remote.origin.url', {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'pipe']
    }).trim();
    const repo = parseRepoFromRemoteUrl(originUrl);
    if (repo) return repo;
  } catch (e) {
    console.debug('æ‰¾ä¸åˆ° originï¼Œä½¿ç”¨é è¨­å€¼', e?.message || e);
  }

  return 'github/awesome-copilot';
};

/**
 * ä½¿ç”¨ GH å‘½ä»¤åˆ—ä»‹é¢ç²å– GitHub ä½¿ç”¨è€…åç¨±çš„å·²åˆä½µ PR ä¸¦éæ¿¾æª”æ¡ˆã€‚
 * @param {string} username
 * @param {{includeAllFiles?:boolean}} [opts]
 * @returns {Array<object>} PR ç‰©ä»¶é™£åˆ—
 */
export const fetchContributorMergedPrs = (username, { includeAllFiles = false } = {}) => {
  try {
    const repo = getGitHubRepo();
    const result = execSync(
      `gh pr list --repo ${repo} --state merged --author ${username} --json number,title,mergedAt,files,url --limit 100`,
      { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'], timeout: DEFAULT_CMD_TIMEOUT }
    );
    const prs = JSON.parse(result);

    if (includeAllFiles) {
      return prs;
    }

    return prs.filter(pr => {
      const hasNonConfigFiles = pr.files.some(file =>
        !isAutoGeneratedFile(file.path)
      );
      return hasNonConfigFiles;
    });
  } catch (error) {
    console.error(`ç„¡æ³•ç²å– ${username} çš„ PR:`, error.message);
    return [];
  }
};

/**
 * å°‡ PR ç‰©ä»¶è½‰æ›ç‚ºåŒ…å«é¡å‹å’Œæª”æ¡ˆè©³ç´°è³‡è¨Šçš„æ­£è¦åŒ–å ±å‘Šé …ç›®ã€‚
 * @param {{login:string}} contributor
 * @param {object} pr
 * @param {{includeAllFiles?:boolean}} [opts]
 * @returns {object|null}
 */
const generatePRReport = (contributor, pr, { includeAllFiles = false } = {}) => {
  const types = new Set();
  const fileDetails = [];

  for (const file of pr.files) {
    if (!file?.path) {
      continue;
    }

    // åƒ…åœ¨ includeAllFiles ç‚º true æ™‚åŒ…å«ç”¢ç”Ÿçš„æª”æ¡ˆ
    if (!includeAllFiles && isAutoGeneratedFile(file.path)) {
      continue;
    }

    const type = getFileContributionType(file.path) || 'ideas';
    if (type) {
      types.add(type);
    }

    fileDetails.push({
      path: file.path,
      type: type || 'unknown',
      additions: file.additions,
      deletions: file.deletions
    });
  }

  // å¦‚æœæ²’æœ‰ééæ¿¾æª”æ¡ˆå°é¡å‹æœ‰è²¢ç»ï¼Œä¸”æœªè¦æ±‚æ‰€æœ‰æª”æ¡ˆï¼Œå‰‡è·³éæ­¤ PR
  if (types.size === 0 && !includeAllFiles) {
    return null;
  }

  // è‹¥æœªåµæ¸¬åˆ°é¡å‹ï¼Œå‰‡å‚™æ¡ˆç‚º 'code'
  if (types.size === 0) {
    types.add('code');
  }

  const typeList = Array.from(types);

  return {
    prNumber: pr.number,
    prTitle: pr.title,
    prUrl: pr.url,
    mergedAt: pr.mergedAt,
    contributionTypes: typeList,
    files: fileDetails,
    commentSnippet: `@all-contributors please add @${contributor.login} for ${typeList.join(', ')}`
  };
};

/**
 * é€éæª¢è¦–å·²åˆä½µçš„ PR ä¸¦å°‡æª”æ¡ˆå°æ‡‰åˆ°é¡å‹ä¾†å»ºæ§‹è²¢ç»è€…å ±å‘Šã€‚
 * è‹¥æœªæ‰¾åˆ°ç›¸é—œ PR (é™¤é includeAllFiles ç‚º true)ï¼Œå‰‡å‚³å› nullã€‚
 * @param {string} username
 * @param {{includeAllFiles?:boolean}} [opts]
 * @returns {object|null}
 */
export const generateContributorReport = (username, { includeAllFiles = false } = {}) => {
  console.log(`æ­£åœ¨æª¢æŸ¥ ${username}...`);

  const prs = fetchContributorMergedPrs(username, { includeAllFiles });
  const prReports = prs
    .map(pr => generatePRReport({ login: username }, pr, { includeAllFiles }))
    .filter(report => report !== null);

  // å¦‚æœæ²’æœ‰ç›¸é—œçš„ PR å ±å‘Šä¸”æœªæ˜ç¢ºåŒ…å«æ‰€æœ‰æª”æ¡ˆï¼Œå‰‡å®Œå…¨è·³éè©²è²¢ç»è€…
  if (prReports.length === 0 && !includeAllFiles) {
    return null;
  }

  return {
    username,
    totalPRs: prs.length,
    prs: prReports
  };
};

/**
 * å°‡ä¸€çµ„è²¢ç»è€…å ±å‘Šæ¸²æŸ“ç‚º markdown ä»¥ä¾›äººå·¥æª¢è¦–ã€‚
 * @param {Array<object>} reports
 * @param {number} missingCount - åµæ¸¬åˆ°çš„ç¼ºå¤±è²¢ç»è€…æ•¸é‡
 * @returns {string}
 */
export const generateMarkdownReport = (reports, missingCount = 0) => {
  if (!missingCount) {
    return 'æœªåµæ¸¬åˆ°ç¼ºå¤±çš„è²¢ç»è€…ã€‚\n';
  }

  const nowIso = new Date().toISOString();

  const computeTypesArg = (report) => {
    const typeSet = new Set();
    for (const pr of report.prs || []) {
      for (const type of pr.contributionTypes || []) {
        if (type) {
          typeSet.add(type);
        }
      }
    }

    const types = Array.from(typeSet).sort((a, b) => a.localeCompare(b));
    return types.length > 0 ? types.join(',') : 'code';
  };

  const lines = [];

  lines.push(
    '# ç¼ºå¤±è²¢ç»è€…å ±å‘Š',
    '',
    `ç”¢ç”Ÿæ™‚é–“ (ISO): ${nowIso}`,
    '',
    `ç¼ºå¤±è²¢ç»è€…æ•¸é‡: ${missingCount}`,
    ''
  );

  for (const report of reports) {
    lines.push(`## @${report.username}`);

    const prs = Array.from(report.prs || []).sort((a, b) => {
      // å„ªå…ˆé¡¯ç¤ºæœ€è¿‘çš„ PRã€‚
      const aTime = a.mergedAt ? Date.parse(a.mergedAt) : 0;
      const bTime = b.mergedAt ? Date.parse(b.mergedAt) : 0;
      if (aTime !== bTime) return bTime - aTime;
      return (b.prNumber ?? 0) - (a.prNumber ?? 0);
    });

    if (prs.length === 0) {
      lines.push(
        '',
        '_æœªæ‰¾åˆ°ç¬¦åˆæ¢ä»¶çš„ PRã€‚_',
        '',
        `æ›¿ä»£å‘½ä»¤åˆ—ï¼š\`npx all-contributors add ${report.username} ${computeTypesArg(report)}\``,
        '',
        '---',
        ''
      );
      continue;
    }

    lines.push('');

    for (const pr of prs) {
      const prTypes = (pr.contributionTypes || []).filter(Boolean);
      const prTypesArg = prTypes.length > 0 ? prTypes.join(', ') : 'code';
      const title = String(pr.prTitle ?? '');
      const url = String(pr.prUrl ?? '');
      const comment = `@all-contributors please add @${report.username} for ${prTypesArg}`;

      lines.push(
        `[#${pr.prNumber}](${url}) ${title}`,
        '```plaintext',
        comment,
        '```'
      );
    }

    lines.push(
      '',
      '### æ›¿ä»£å‘½ä»¤åˆ—æŒ‡ä»¤',
      '',
      '```bash',
      `npx all-contributors add ${report.username} ${computeTypesArg(report)}`,
      '```',
      '',
      '---',
      ''
    );
  }

  return `${lines.join('\n')}\n`;
};

const main = () => {
  try {
    // gh å‘½ä»¤åˆ—ä»‹é¢å¯ä»¥ä½¿ç”¨å…¶è‡ªèº«çš„é©—è­‰å·¥ä½œéšæ®µæˆ–æ¬Šæ–ç’°å¢ƒè®Šæ•¸ã€‚
    // åœ¨ CI ä¸­ï¼Œæˆ‘å€‘é€šå¸¸é€é PRIVATE_TOKEN æ¥æ”¶æ¬Šæ–ã€‚
    if (process.env.PRIVATE_TOKEN && !process.env.GITHUB_TOKEN && !process.env.GH_TOKEN) {
      process.env.GITHUB_TOKEN = process.env.PRIVATE_TOKEN;
    }

    // gh åå¥½ GH_TOKENï¼›å¦‚æœæˆ‘å€‘åªæœ‰ GITHUB_TOKENï¼Œè«‹æ˜ç¢ºè¨­å®š GH_TOKENã€‚
    if (process.env.GITHUB_TOKEN && !process.env.GH_TOKEN) {
      process.env.GH_TOKEN = process.env.GITHUB_TOKEN;
    }

    const args = new Set(process.argv.slice(2));
    const includeAllFiles = args.has('--include-all-pr-files');

    const contributors = getMissingContributors();
    console.log(`æ­£åœ¨æª¢æŸ¥ ${contributors.length} ä½ç¼ºå¤±çš„è²¢ç»è€…...\n`);

    const reports = [];
    for (const contributor of contributors) {
      const report = generateContributorReport(contributor, { includeAllFiles });
      reports.push(report || { username: contributor, totalPRs: 0, prs: [] });
    }

    const markdown = generateMarkdownReport(reports, contributors.length);
    const outputPath = path.join(process.cwd(), 'reports', 'contributor-report.md');
    fs.writeFileSync(outputPath, markdown);

    console.log(`å ±å‘Šå·²å„²å­˜è‡³ï¼š${outputPath}`);

  } catch (error) {
    console.error('ç”¢ç”Ÿå ±å‘Šæ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š', error);
    process.exit(1);
  }
};

if (process.argv[1] && fileURLToPath(import.meta.url) === path.resolve(process.argv[1])) {
  main();
}
