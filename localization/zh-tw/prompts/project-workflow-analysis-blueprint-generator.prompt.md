---

description: '全面且技術中立的提示產生器，用於記錄端到端應用程式工作流程。可自動偵測專案架構模式、技術堆疊與資料流模式，產生詳細的實作藍圖，涵蓋進入點、服務層、資料存取、錯誤處理與測試方法，支援多種技術如 .NET、Java/Spring、React 及微服務架構。'

---
# 專案工作流程文件產生器

## 設定變數

```
${PROJECT_TYPE="自動偵測|.NET|Java|Spring|Node.js|Python|React|Angular|微服務|其他"}
<!-- 主要技術堆疊 -->

${ENTRY_POINT="API|GraphQL|前端|CLI|訊息消費者|排程作業|自訂"}
<!-- 流程起始點 -->

${PERSISTENCE_TYPE="自動偵測|SQL 資料庫|NoSQL 資料庫|檔案系統|外部 API|訊息佇列|快取|無"}
<!-- 資料儲存型態 -->

${ARCHITECTURE_PATTERN="自動偵測|分層|Clean|CQRS|微服務|MVC|MVVM|Serverless|事件驅動|其他"}
<!-- 主要架構模式 -->

${WORKFLOW_COUNT=1-5}
<!-- 要記錄的工作流程數量 -->

${DETAIL_LEVEL="標準|可直接實作"}
<!-- 包含的實作細節層級 -->

${INCLUDE_SEQUENCE_DIAGRAM=true|false}
<!-- 產生序列圖 -->

${INCLUDE_TEST_PATTERNS=true|false}
<!-- 包含測試方法 -->
```

## 產生的提示

```
「分析程式碼庫並記錄 ${WORKFLOW_COUNT} 個具代表性的端到端工作流程，
可作為類似功能的實作範本。請依以下方式進行：
```

### 初始偵測階段

```
${PROJECT_TYPE == "自動偵測" ? 
  "先檢查程式碼庫結構以辨識技術：
   - 檢查 .NET 解決方案/專案、Spring 設定、Node.js/Express 檔案等
   - 辨識主要程式語言與使用的框架
   - 根據資料夾結構與主要元件判斷架構模式" 
  : "聚焦於 ${PROJECT_TYPE} 的模式與慣例"}
```

```
${ENTRY_POINT == "自動偵測" ? 
  "尋找典型進入點：
   - API 控制器或路由定義
   - GraphQL 解析器
   - 發起網路請求的 UI 元件
   - 訊息處理器或事件訂閱者
   - 排程作業定義" 
  : "聚焦於 ${ENTRY_POINT} 進入點"}
```

```
${PERSISTENCE_TYPE == "自動偵測" ? 
  "判斷持久化機制：
   - 資料庫連線/設定
   - 資料儲存庫實作
   - ORM 映射
   - 外部 API 客戶端
   - 檔案系統互動" 
  : "聚焦於 ${PERSISTENCE_TYPE} 互動"}
```

### 工作流程文件說明

針對系統中最具代表性的 `${WORKFLOW_COUNT}` 個工作流程：

#### 1. 工作流程概述
   - 提供流程名稱與簡要說明
   - 說明其商業目的
   - 指出觸發動作或事件
   - 列出完整流程涉及的所有檔案/類別

#### 2. 進入點實作

**API 進入點：**
```
${ENTRY_POINT == "API" || ENTRY_POINT == "自動偵測" ? 
  "- 記錄接收請求的 API 控制器類別與方法
   - 顯示完整方法簽名（含屬性/註解）
   - 包含完整請求 DTO/模型類別定義
   - 記錄驗證屬性與自訂驗證器
   - 顯示認證/授權屬性與檢查" : ""}
```

**GraphQL 進入點：**
```
${ENTRY_POINT == "GraphQL" || ENTRY_POINT == "自動偵測" ? 
  "- 記錄 GraphQL 解析器類別與方法
   - 顯示查詢/變更的完整 schema 定義
   - 包含輸入型別定義
   - 顯示解析器方法實作與參數處理" : ""}
```

**前端進入點：**
```
${ENTRY_POINT == "前端" || ENTRY_POINT == "自動偵測" ? 
  "- 記錄發起 API 呼叫的元件
   - 顯示觸發請求的事件處理器
   - 包含 API 客戶端服務方法
   - 顯示與請求相關的狀態管理程式碼" : ""}
```

**訊息消費者進入點：**
```
${ENTRY_POINT == "訊息消費者" || ENTRY_POINT == "自動偵測" ? 
  "- 記錄訊息處理類別與方法
   - 顯示訊息訂閱設定
   - 包含完整訊息模型定義
   - 顯示反序列化與驗證邏輯" : ""}
```

#### 3. 服務層實作
   - 記錄涉及的每個服務類別及其相依性
   - 顯示完整方法簽名（含參數與回傳型別）
   - 包含實際方法實作與主要商業邏輯
   - 記錄介面定義（如適用）
   - 顯示相依性注入註冊模式

**CQRS 模式：**
```
${ARCHITECTURE_PATTERN == "CQRS" || ARCHITECTURE_PATTERN == "自動偵測" ? 
  "- 包含完整命令/查詢處理器實作" : ""}
```

**Clean Architecture 模式：**
```
${ARCHITECTURE_PATTERN == "Clean" || ARCHITECTURE_PATTERN == "自動偵測" ? 
  "- 顯示用例/互動器實作" : ""}
```

#### 4. 資料對應模式
   - 記錄 DTO 與領域模型的對應程式碼
   - 顯示物件對應器設定或手動對應方法
   - 包含對應時的驗證邏輯
   - 記錄對應過程產生的領域事件

#### 5. 資料存取實作
   - 記錄儲存庫介面及其實作
   - 顯示完整方法簽名（含參數與回傳型別）
   - 包含實際查詢實作
   - 記錄實體/模型類別定義（含所有屬性）
   - 顯示交易處理模式

**SQL 資料庫模式：**
```
${PERSISTENCE_TYPE == "SQL 資料庫" || PERSISTENCE_TYPE == "自動偵測" ? 
  "- 包含 ORM 設定、註解或 Fluent API 用法
   - 顯示實際 SQL 查詢或 ORM 陳述式" : ""}
```

**NoSQL 資料庫模式：**
```
${PERSISTENCE_TYPE == "NoSQL 資料庫" || PERSISTENCE_TYPE == "自動偵測" ? 
  "- 顯示文件結構定義
   - 包含文件查詢/更新操作" : ""}
```

#### 6. 回應建構
   - 記錄回應 DTO/模型類別定義
   - 顯示從領域/實體模型對應到回應模型的程式碼
   - 包含狀態碼選擇邏輯
   - 記錄錯誤回應結構與產生方式

#### 7. 錯誤處理模式
   - 記錄流程中使用的例外型別
   - 顯示各層的 try/catch 模式
   - 包含全域例外處理器設定
   - 記錄錯誤日誌實作
   - 顯示重試政策或斷路器模式
   - 包含失敗情境的補償行為

#### 8. 非同步處理模式
   - 記錄背景作業排程程式碼
   - 顯示事件發布實作
   - 包含訊息佇列傳送模式
   - 記錄 callback 或 webhook 實作
   - 顯示非同步操作的追蹤與監控方式

**測試方法（選用）：**
```
${INCLUDE_TEST_PATTERNS ? 
  "9. **測試方法**
     - 記錄各層的單元測試實作
     - 顯示模擬模式與測試基底設定
     - 包含整合測試實作
     - 記錄測試資料產生方式
     - 顯示 API/控制器測試實作" : ""}
```

**序列圖（選用）：**
```
${INCLUDE_SEQUENCE_DIAGRAM ? 
  "10. **序列圖**
      - 產生詳細序列圖，顯示所有元件
      - 包含方法呼叫與參數型別
      - 顯示元件間回傳值
      - 記錄條件流程與錯誤路徑" : ""}
```

#### 11. 命名慣例
記錄一致性模式：
- 控制器命名（如 `EntityNameController`）
- 服務命名（如 `EntityNameService`）
- 儲存庫命名（如 `IEntityNameRepository`）
- DTO 命名（如 `EntityNameRequest`, `EntityNameResponse`）
- CRUD 操作方法命名模式
- 變數命名慣例
- 檔案組織模式

#### 12. 實作範本
提供可重複使用的程式碼範本：
- 建立新 API 端點
- 實作新服務方法
- 新增儲存庫方法
- 建立新領域模型類別
- 正確實作錯誤處理

### 技術專屬實作模式

**.NET 實作模式（如偵測到）：**
```
${PROJECT_TYPE == ".NET" || PROJECT_TYPE == "自動偵測" ? 
  "- 完整控制器類別（含屬性、過濾器、相依性注入）
   - Startup.cs 或 Program.cs 的服務註冊
   - Entity Framework DbContext 設定
   - EF Core 或 Dapper 的儲存庫實作
   - AutoMapper Profile 設定
   - 跨層中介軟體實作
   - 擴充方法模式
   - Options 設定模式
   - ILogger 日誌實作
   - 認證/授權過濾器或政策實作" : ""}
```

**Spring 實作模式（如偵測到）：**
```
${PROJECT_TYPE == "Java" || PROJECT_TYPE == "Spring" || PROJECT_TYPE == "自動偵測" ? 
  "- 完整控制器類別（含註解與相依性注入）
   - 具交易界限的服務實作
   - 儲存庫介面與實作
   - JPA 實體定義（含關聯）
   - DTO 類別實作
   - Bean 設定與元件掃描
   - 例外處理器實作
   - 自訂驗證器實作" : ""}
```

**React 實作模式（如偵測到）：**
```
${PROJECT_TYPE == "React" || PROJECT_TYPE == "自動偵測" ? 
  "- 元件結構（含 props 與 state）
   - Hook 實作模式（useState, useEffect, 自訂 hook）
   - API 服務實作
   - 狀態管理模式（Context, Redux）
   - 表單處理實作
   - 路由設定" : ""}
```

### 實作指引

根據已記錄的工作流程，提供新增功能的具體實作指引：

#### 1. 步驟式實作流程
- 新增類似功能時的起始位置
- 實作順序（如模型 → 儲存庫 → 服務 → 控制器）
- 如何整合現有橫切關注點

#### 2. 常見陷阱
- 指出目前實作中易出錯區域
- 注意效能考量
- 列出常見錯誤或問題

#### 3. 擴充機制
- 記錄如何掛接現有擴充點
- 顯示如何新增行為而不修改既有程式碼
- 說明以設定驅動的功能模式

**結論：**
以摘要方式說明新增功能時應遵循的最重要模式，
以維持程式碼庫的一致性。

---

**免責聲明**：本文件由 [GitHub Copilot](https://docs.github.com/copilot/about-github-copilot/what-is-github-copilot) 在地化產生，因此可能包含錯誤。如發現不適當或錯誤翻譯，請至 [issue](../../issues) 回報。
