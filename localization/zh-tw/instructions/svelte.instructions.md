---
description: 'Svelte 5 和 SvelteKit 應用程式開發標準與最佳實踐，用於基於元件的使用者介面和全端應用程式'
applyTo: '**/*.svelte, **/*.ts, **/*.js, **/*.css, **/*.scss, **/*.json'
---

# Svelte 5 和 SvelteKit 開發指示

用於建構高品質 Svelte 5 和 SvelteKit 應用程式的指示，採用現代基於符文的響應性、TypeScript 和效能最佳化。

## 專案內容
- 採用符文系統的 Svelte 5.x ($state, $derived, $effect, $props, $bindable)
- 適用於具有檔案型路由的全端應用程式的 SvelteKit
- 用於型別安全和更好開發者體驗的 TypeScript
- 採用 CSS 自訂屬性的元件範圍樣式
- 漸進式增強和效能優先的方法
- 採用最佳化的現代建構工具 (Vite)

## 開發標準

### 架構
- 對於所有響應性，使用 Svelte 5 符文系統而不是傳統的儲存
- 依據功能或領域組織元件以實現延展性
- 將呈現元件與邏輯繁重的元件分離
- 將可重用邏輯提取到可組合的函式中
- 使用插槽和片段實現適當的元件組合
- 使用 SvelteKit 的檔案型路由和適當的載入函式

### TypeScript 整合
- 在 `tsconfig.json` 中啟用嚴格模式以實現最大型別安全
- 使用 `$props()` 語法定義元件屬性的介面
- 型別事件處理程式、refs 和 SvelteKit 生成的型別
- 對於可重用元件使用泛型型別
- 利用 SvelteKit 生成的 `$types.ts` 檔案
- 使用 `svelte-check` 實現適當的型別檢查

### 元件設計
- 遵循元件的單一職責原則
- 預設使用帶有符文語法的 `<script lang="ts">`
- 保持元件小巧並專注於一個關注點
- 使用 TypeScript 實現適當的屬性驗證
- 使用插槽和片段進行靈活組合
- 設計可測試和可重用的元件

### Svelte 5 符文系統
- 使用 `$state()` 進行響應式本地狀態管理
- 實作 `$derived()` 用於計算值和昂貴的計算
- 使用 `$effect()` 進行帶有適當清理的副作用
- 使用 `$props()` 和解構定義元件屬性
- 使用 `$bindable()` 進行元件之間的雙向資料綁定
- 從傳統儲存遷移到符文以獲得更好的效能

### 狀態管理
- 使用 `$state()` 進行本地元件狀態
- 使用 `setContext`/`getContext` 實現上下文 API 以共享狀態
- 在需要時使用 SvelteKit 儲存進行全域應用程式狀態
- 保持複雜資料結構的狀態正規化
- 使用衍生狀態進行計算值
- 實現客戶端資料的適當狀態持久性

### SvelteKit 模式
- 使用 `+page.svelte` 進行具有適當 SEO 的頁面元件
- 實作 `+layout.svelte` 用於共享佈局和導航
- 使用 `+page.server.ts` 進行伺服器端資料載入和 API 呼叫
- 在 `+page.server.ts` 中實作表單動作以進行資料變更
- 使用 `+server.ts` 進行 API 端點和伺服器端邏輯
- 使用 SvelteKit 的檔案型系統處理路由

### 樣式
- 使用帶有 `<style>` 區塊的元件範圍樣式
- 實作 CSS 自訂屬性用於主題和設計系統
- 使用 `class:` 指令進行條件樣式
- 遵循 BEM 或 utility-first CSS 慣例
- 採用行動優先方法實作響應式設計
- 謹慎使用 `:global()` 進行真正的全域樣式

### 效能最佳化
- 使用帶鍵的 `{#each}` 區塊進行高效的列表呈現
- 使用動態匯入和 `svelte:component` 實作延遲載入
- 使用 `$derived()` 進行昂貴的計算以避免不必要的重新計算
- 利用 SvelteKit 的自動程式碼分割和預載入
- 透過 tree shaking 和適當的匯入最佳化套件大小
- 使用 Svelte DevTools 進行分析以識別效能瓶頸

### 資料擷取
- 使用 SvelteKit 的載入函式進行伺服器端和通用資料擷取
- 實作適當的載入、錯誤和成功狀態
- 在伺服器載入函式中使用 promise 處理串流資料
- 使用 `invalidate()` 和 `invalidateAll()` 進行快取管理
- 實作樂觀更新以獲得更好的使用者體驗
- 優雅地處理離線情境和網路錯誤

### 錯誤處理
- 實作 `+error.svelte` 頁面用於路由級別的錯誤邊界
- 在載入函式和表單動作中使用 try/catch 區塊
- 提供有意義的錯誤訊息和備用 UI
- 適當地記錄錯誤以進行偵錯和監控
- 使用適當的使用者回饋處理表單中的驗證錯誤
- 使用 SvelteKit 的錯誤和重定向輔助函式

### 表單和驗證
- 使用 SvelteKit 的表單動作進行伺服器端表單處理
- 使用 `use:enhance` 實作漸進式增強
- 使用 `bind:value` 進行受控表單輸入
- 在客戶端和伺服器端驗證資料
- 處理檔案上傳和複雜的表單情境
- 使用標籤和 ARIA 屬性實作適當的可存取性

### 測試
- 使用 Vitest 和 Testing Library 為元件編寫單元測試
- 測試元件行為，而不是實作細節
- 使用 Playwright 進行使用者工作流程的端到端測試
- 適當地模擬 SvelteKit 的載入函式和儲存
- 徹底測試表單動作和 API 端點
- 使用 axe-core 實作可存取性測試

### 安全性
- 清理使用者輸入以防止 XSS 攻擊
- 謹慎使用 `@html` 指令並驗證 HTML 內容
- 使用 SvelteKit 實作適當的 CSRF 保護
- 在載入函式和表單動作中驗證和清理資料
- 對於所有外部 API 呼叫和生產部署使用 HTTPS
- 透過適當的會話管理安全地儲存敏感資料

### 可存取性
- 使用語義 HTML 元素和適當的標題層次結構
- 為所有互動元素實作鍵盤導航
- 提供適當的 ARIA 標籤和描述
- 確保顏色對比符合 WCAG 指南
- 使用螢幕閱讀器和可存取性工具進行測試
- 實作動態內容的焦點管理

## 實作流程
1. 使用 TypeScript 和所需的適配器初始化 SvelteKit 專案
2. 透過適當的資料夾組織設定專案結構
3. 定義 TypeScript 介面和元件屬性
4. 使用 Svelte 5 符文實作核心元件
5. 使用 SvelteKit 新增路由、佈局和導航
6. 實作資料載入和表單處理
7. 使用自訂屬性和響應式設計新增樣式系統
8. 實作錯誤處理和載入狀態
9. 新增全面的測試覆蓋範圍
10. 最佳化效能和套件大小
11. 確保可存取性合規性
12. 使用適當的 SvelteKit 適配器部署

## 其他指南
- 遵循 Svelte 的命名慣例（元件使用 PascalCase，函式使用 camelCase）
- 使用 ESLint 搭配 eslint-plugin-svelte 和 Prettier 進行程式碼一致性
- 保持依賴項最新並審核安全漏洞
- 使用 JSDoc 文件化複雜元件和邏輯
- 使用 Svelte DevTools 進行偵錯和效能分析
- 使用 SvelteKit 的 meta 標籤和結構化資料實作適當的 SEO
- 使用環境變數進行不同部署階段的組態

## 常見模式
- 帶有插槽的無渲染元件，用於靈活的 UI 組合
- 用於跨領域關注點和 DOM 操作的自訂指令
- 基於片段的組合，用於可重用的模板邏輯
- 用於應用程式範圍狀態管理的上下文提供者
- 表單和互動功能的漸進式增強
- 帶有客戶端水合的伺服器端呈現，以實現最佳效能
