---
description: '撰寫 Dart 與 Flutter 程式碼時，遵循官方建議的指引。'
applyTo: '**/*.dart'
---

# Dart 與 Flutter

Dart 與 Flutter 團隊推薦的最佳實踐。本指引內容取自 [Effective Dart](https://dart.dev/effective-dart) 及 [架構建議](https://docs.flutter.dev/app-architecture/recommendations)。

## Effective Dart

過去幾年，我們撰寫了大量 Dart 程式碼，並學習到哪些做法有效、哪些無效。我們希望與你分享這些經驗，讓你也能寫出一致、健壯且高效的程式碼。主要有兩個核心主題：

1. **保持一致。** 關於格式化、命名等問題，哪種做法較好往往是主觀且難以定論。但我們知道，*一致性* 對於程式碼品質是客觀有益的。

    如果兩段程式碼看起來不同，應該是因為它們在某些有意義的地方真的不同。當某段程式碼引起你的注意時，應該是因為它有值得注意的理由。

2. **簡潔明瞭。** Dart 設計上追求熟悉感，因此繼承了許多 C、Java、JavaScript 等語言的語法。但我們創造 Dart，是因為這些語言仍有改進空間。我們加入了許多功能，像是字串插值、初始化參數等，讓你能更簡單明確地表達意圖。

    如果有多種寫法，通常應選擇最簡潔的方式。但這不代表要把整個程式壓縮成一行（code golf）。目標是讓程式碼 *精簡*，而非 *密集*。

### 主題分類

我們將指引分為幾個主題，方便閱讀：

*   **風格** – 定義程式碼的排版與組織規則，或至少是 `dart format` 無法自動處理的部分。也包含識別字的命名規則：`camelCase`、`using_underscores` 等。

*   **文件** – 闡述註解內容的撰寫方式，包括文件註解與一般程式註解。

*   **用法** – 教你如何善用語言特性來實現行為。只要是語句或運算式，都屬於此主題。

*   **設計** – 雖然較為抽象，但涵蓋範圍最廣。分享設計一致且易用的 API 經驗。只要是型別簽名或宣告，都屬於此主題。

### 如何閱讀主題

每個主題分為幾個章節。章節內有多條指引，每條指引開頭會用以下詞彙：

*   **DO**：必須遵循的做法，幾乎沒有例外。

*   **DON'T**：反面指引，幾乎不建議這麼做。

*   **PREFER**：建議遵循，但在某些情況下可例外。若要忽略，請確實了解其影響。

*   **AVOID**：不建議這麼做，但在極少數情況下可例外。

*   **CONSIDER**：可依情況、慣例或個人偏好選擇是否遵循。

部分指引會說明 **例外**，但未必詳列所有情況，仍需自行判斷。

這些規則並非警察會因你鞋帶沒綁好就破門而入。大多數指引都是常識，目標是讓程式碼更易讀、易維護。

### 規則

#### 風格

##### 識別字

*   DO 使用 `UpperCamelCase` 命名型別。
*   DO 使用 `UpperCamelCase` 命名擴充。
*   DO 使用 `lowercase_with_underscores` 命名套件、目錄與原始檔。
*   DO 使用 `lowercase_with_underscores` 命名匯入前綴。
*   DO 其他識別字使用 `lowerCamelCase`。
*   PREFER 常數名稱使用 `lowerCamelCase`。
*   DO 將超過兩個字母的縮寫與簡稱視為單字並大寫。
*   PREFER 未使用的回呼參數使用萬用字元。
*   DON'T 為非私有識別字加前導底線。
*   DON'T 使用前綴字母。
*   DON'T 明確命名程式庫。

##### 排序

*   DO 先放 `dart:` 匯入。
*   DO 先放 `package:` 匯入，再放相對路徑匯入。
*   DO 匯出應獨立於匯入之後。
*   DO 各區塊按字母排序。

##### 格式化

*   DO 使用 `dart format` 格式化程式碼。
*   CONSIDER 調整程式碼以利格式化工具運作。
*   PREFER 每行不超過 80 字元。
*   DO 所有流程控制語句都加上大括號。

#### 文件

##### 註解

*   DO 註解以句子格式撰寫。
*   DON'T 使用區塊註解撰寫文件。

##### 文件註解

*   DO 使用 `///` 文件註解描述成員與型別。
*   PREFER 公開 API 撰寫文件註解。
*   CONSIDER 為程式庫層級撰寫文件註解。
*   CONSIDER 為私有 API 撰寫文件註解。
*   DO 文件註解以單句摘要開頭。
*   DO 文件註解首句獨立成段。
*   AVOID 與周遭內容重複。
*   PREFER 若函式或方法主要目的是副作用，註解以第三人稱動詞開頭。
*   PREFER 非布林變數或屬性註解以名詞片語開頭。
*   PREFER 布林變數或屬性註解以「Whether」加名詞或動名詞片語開頭。
*   PREFER 若函式或方法主要回傳值，註解以名詞片語或非命令式動詞片語開頭。
*   DON'T 同時為屬性的 getter 與 setter 撰寫文件。
*   PREFER 程式庫或型別註解以名詞片語開頭。
*   CONSIDER 文件註解中加入程式範例。
*   DO 文件註解中用中括號參照範圍內識別字。
*   DO 文件註解以文字說明參數、回傳值與例外。
*   DO 文件註解放在中繼資料註解之前。

##### Markdown

*   AVOID 過度使用 markdown。
*   AVOID 使用 HTML 格式化。
*   PREFER 程式碼區塊用反引號標示。

##### 撰寫

*   PREFER 簡潔。
*   AVOID 使用不明顯的縮寫與簡稱。
*   PREFER 用 "this" 取代 "the" 指稱成員實例。

#### 用法

##### 程式庫

*   DO `part of` 指令使用字串。
*   DON'T 匯入其他套件 `src` 目錄下的程式庫。
*   DON'T 匯入路徑跨越 `lib` 目錄。
*   PREFER 使用相對匯入路徑。

##### Null

*   DON'T 明確將變數初始化為 `null`。
*   DON'T 明確預設值設為 `null`。
*   DON'T 在等值運算中使用 `true` 或 `false`。
*   AVOID 若需檢查是否初始化，避免使用 `late` 變數。
*   CONSIDER 使用型別提升或 null 檢查模式處理可為 null 型別。

##### 字串

*   DO 使用相鄰字串連接字串常值。
*   PREFER 用插值組合字串與值。
*   AVOID 插值時不必要的大括號。

##### 集合

*   DO 優先使用集合常值。
*   DON'T 用 `.length` 判斷集合是否為空。
*   AVOID 用 `Iterable.forEach()` 搭配函式。
*   DON'T 用 `List.from()`，除非要改變回傳型別。
*   DO 用 `whereType()` 依型別篩選集合。
*   DON'T 用 `cast()`，若附近操作可達成目的。
*   AVOID 使用 `cast()`。

##### 函式

*   DO 用函式宣告綁定函式名稱。
*   DON'T 用 lambda，若可用 tear-off。

##### 變數

*   DO 本地變數 `var` 與 `final` 遵循一致規則。
*   AVOID 儲存可計算的值。

##### 成員

*   DON'T 不必要地用 getter 與 setter 包裝欄位。
*   PREFER 用 `final` 欄位建立唯讀屬性。
*   CONSIDER 簡單成員用 `=>`。
*   DON'T 用 `this.`，除非重定向至命名建構函式或避免遮蔽。
*   DO 欄位盡可能於宣告時初始化。

##### 建構函式

*   DO 優先用初始化參數。
*   DON'T 用 `late`，若建構函式初始化列表可達成。
*   DO 空建構函式用 `;` 取代 `{}`。
*   DON'T 用 `new`。
*   DON'T 重複用 `const`。

##### 錯誤處理

*   AVOID 無 `on` 子句的 catch。
*   DON'T 無 `on` 子句的 catch 丟棄錯誤。
*   DO 只丟出實作 `Error` 的物件以表示程式錯誤。
*   DON'T 明確 catch `Error` 或其實作型別。
*   DO 用 `rethrow` 重新丟出捕獲的例外。

##### 非同步

*   PREFER 用 async/await 取代原始 future。
*   DON'T 無實質效果時用 `async`。
*   CONSIDER 用高階方法轉換 stream。
*   AVOID 直接用 Completer。
*   DO 判斷 `Future<T>` 以區分型別為 `Object` 的 `FutureOr<T>`。

#### 設計

##### 命名

*   DO 用詞一致。
*   AVOID 使用縮寫。
*   PREFER 最具描述性的名詞放最後。
*   CONSIDER 讓程式碼像句子。
*   PREFER 非布林屬性或變數用名詞片語。
*   PREFER 布林屬性或變數用非命令式動詞片語。
*   CONSIDER 命名布林參數時省略動詞。
*   PREFER 布林屬性或變數用正向命名。
*   PREFER 主要副作用的函式或方法用命令式動詞片語。
*   PREFER 主要回傳值的函式或方法用名詞片語或非命令式動詞片語。
*   CONSIDER 若要強調執行內容，可用命令式動詞片語。
*   AVOID 方法名稱以 `get` 開頭。
*   PREFER 若方法複製物件狀態至新物件，命名為 `to...()`。
*   PREFER 若方法回傳原物件的不同表示，命名為 `as...()`。
*   AVOID 在函式或方法名稱描述參數。
*   DO 命名型別參數時遵循既有助記慣例。

##### 程式庫

*   PREFER 宣告為私有。
*   CONSIDER 同一程式庫宣告多個類別。

##### 類別與 mixin

*   AVOID 只含一成員的抽象類別，若可用函式取代。
*   AVOID 只含靜態成員的類別。
*   AVOID 繼承非設計為可繼承的類別。
*   DO 用類別修飾詞控制是否可繼承。
*   AVOID 實作非設計為介面的類別。
*   DO 用類別修飾詞控制是否可作為介面。
*   PREFER 純 `mixin` 或純 `class`，勝於 `mixin class`。

##### 建構函式

*   CONSIDER 若類別支援，建構函式設為 `const`。

##### 成員

*   PREFER 欄位與頂層變數設為 `final`。
*   DO 屬性存取操作用 getter。
*   DO 屬性變更操作用 setter。
*   DON'T 定義 setter 而無對應 getter。
*   AVOID 用執行期型別測試偽裝多載。
*   AVOID 公開 `late final` 欄位無初始化。
*   AVOID 回傳可為 null 的 `Future`、`Stream` 與集合型別。
*   AVOID 僅為實現 fluent interface 而回傳 `this`。

##### 型別

*   DO 無初始化的變數加型別註記。
*   DO 型別不明顯時，欄位與頂層變數加型別註記。
*   DON'T 已初始化的本地變數重複加型別註記。
*   DO 函式宣告加回傳型別註記。
*   DO 函式宣告加參數型別註記。
*   DON'T 函式運算式推斷型別時重複加參數型別註記。
*   DON'T 初始化參數加型別註記。
*   DO 泛型呼叫未推斷時加型別參數。
*   DON'T 泛型呼叫已推斷時加型別參數。
*   AVOID 寫不完整的泛型型別。
*   DO 用 `dynamic` 註記，避免推斷失敗。
*   PREFER 函式型別註記用簽名。
*   DON'T setter 指定回傳型別。
*   DON'T 用舊式 typedef 語法。
*   PREFER 參數用內嵌函式型別。
*   PREFER 參數用函式型別語法。
*   AVOID 用 `dynamic`，除非要停用靜態檢查。
*   DO 非回傳值的非同步成員回傳型別用 `Future<void>`。
*   AVOID 回傳型別用 `FutureOr<T>`。

##### 參數

*   AVOID 位置布林參數。
*   AVOID 若使用者可能省略前面參數，避免用可選位置參數。
*   AVOID 強制參數接受特殊「無參數」值。
*   DO 範圍參數用包含起始、排除結束。

##### 相等性

*   DO 覆寫 `==` 時也覆寫 `hashCode`。
*   DO `==` 運算子遵守數學相等規則。
*   AVOID 為可變類別定義自訂相等性。
*   DON'T `==` 的參數設為可為 null。

---

## Flutter 架構建議

本頁提供架構最佳實踐、其重要性，以及是否推薦於你的 Flutter 應用程式中採用。
請將這些建議視為參考，而非絕對規則，並依你的應用需求調整。

本頁最佳實踐有優先等級，反映 Flutter 團隊推薦強度：

* **強烈推薦：** 新建應用時應始終實作此建議。若不會與現有架構衝突，建議重構既有應用以採用此做法。
* **推薦：** 此做法通常能提升應用品質。
* **有條件：** 某些情況下可提升應用品質。

### 關注點分離

應將應用分為 UI 層與資料層，並於各層依職責細分邏輯至不同類別。

#### 明確劃分資料層與 UI 層
**強烈推薦**

關注點分離是最重要的架構原則。資料層負責向應用其他部分提供資料，並包含大部分商業邏輯。UI 層負責顯示資料並監聽使用者事件，並將 UI 邏輯與元件分開。

#### 資料層採用 repository pattern
**強烈推薦**

Repository pattern 是一種將資料存取邏輯與應用其他部分隔離的設計模式。
它在商業邏輯與底層資料儲存（資料庫、API、檔案系統等）間建立抽象層。實務上，這代表建立 Repository 類別與 Service 類別。

#### UI 層採用 ViewModel 與 View（MVVM）
**強烈推薦**

關注點分離是最重要的架構原則。此分離能大幅降低錯誤，讓元件保持「愚蠢」。

#### 用 `ChangeNotifier` 與 `Listenable` 處理元件更新
**有條件**

> 狀態管理方式眾多，最終取決於個人偏好。

`ChangeNotifier` API 屬於 Flutter SDK，方便元件監聽 ViewModel 變化。

#### 不要將邏輯寫在元件內
**強烈推薦**

邏輯應封裝於 ViewModel 方法。View 只應包含：
* 根據 ViewModel 旗標或可為 null 欄位顯示/隱藏元件的簡單 if 判斷
* 依賴元件計算的動畫邏輯
* 根據裝置資訊（螢幕大小、方向等）調整的排版邏輯
* 簡單的路由邏輯

#### 使用 domain layer
**有條件**

> 僅於邏輯極為複雜時採用。

若應用邏輯過於複雜導致 ViewModel 難以維護，或多個 ViewModel 重複邏輯，可考慮加入 domain layer。
大型應用中 use-case 有幫助，但多數應用則增加負擔。

### 資料處理

妥善處理資料能讓程式碼更易理解、降低錯誤，並防止產生不正確或異常資料。

#### 採用單向資料流
**強烈推薦**

資料更新僅能由資料層流向 UI 層。UI 層互動傳送至資料層處理。

#### 用 `Command` 處理使用者互動事件
**推薦**

Command 可防止渲染錯誤，並標準化 UI 層向資料層傳送事件方式。

#### 資料模型不可變
**強烈推薦**

不可變資料能確保必要變更僅發生於正確位置（通常是資料或 domain 層）。
不可變物件建立後不可修改，需建立新實例反映變更。
此流程可防止 UI 層意外更新，並支持明確的單向資料流。

#### 用 freezed 或 built_value 產生不可變資料模型
**推薦**

可用套件協助產生資料模型常用功能，如 `freezed` 或 `built_value`。
這些套件可自動產生 JSON 序列化/反序列化、深度相等檢查與複製方法。
若模型數量多，這些套件會增加建置時間。

#### API 模型與 domain 模型分開
**有條件**

> 大型應用採用。

分開模型雖增加冗長，但可避免 ViewModel 與 use-case 過於複雜。

### 應用結構

良好組織的程式碼有助於應用健康，也有助於團隊協作。

#### 採用依賴注入
**強烈推薦**

依賴注入可避免全域物件，降低錯誤。建議用 `provider` 套件處理依賴注入。

#### 導航採用 `go_router`
**推薦**

Go_router 適用於 90% 的 Flutter 應用。若遇特殊需求 Go_router 無法解決，可用 Flutter Navigator API 或其他 `pub.dev` 套件。

#### 類別、檔案與目錄命名遵循標準
**推薦**

建議類別名稱反映其架構角色。例如：

* HomeViewModel
* HomeScreen
* UserRepository
* ClientApiService

為避免混淆，建議將共用元件放在 `ui/core/` 目錄，而非 `/widgets`。

#### 抽象 repository 類別
**強烈推薦**

Repository 類別是所有資料的唯一來源，並負責與外部 API 溝通。
建立抽象 repository 類別可讓你針對不同環境（如開發、測試）實作不同版本。

### 測試

良好測試習慣讓應用更具彈性，也讓新增邏輯與 UI 變得簡單且低風險。

#### 架構元件分開測試，也要整合測試
**強烈推薦**

* 為每個 service、repository 與 ViewModel 類別撰寫單元測試，分別測試每個方法邏輯。
* 為 view 撰寫元件測試，特別要測試路由與依賴注入。

#### 為測試建立 fakes（並撰寫可用 fakes 的程式碼）
**強烈推薦**

Fake 不在意方法內部運作，而是關注輸入與輸出。
若以此思維撰寫應用程式碼，能促使你撰寫模組化、輕量且輸入輸出明確的函式與類別。
