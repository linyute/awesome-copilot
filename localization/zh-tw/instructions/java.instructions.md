---
description: '建構 Java 基礎應用程式的指南'
applyTo: '**/*.java'
---

# Java 開發

## 一般指令

- 首先，詢問使用者是否要將靜態分析工具 (SonarQube、PMD、Checkstyle) 整合到他們的專案設定中。
  - 如果是，請記錄建議的靜態分析設定。 
    - 首選 SonarQube/SonarCloud (IDE 中的 SonarLint + CI 中的 `sonar-scanner`)。
    - 建立 Sonar 專案金鑰。
    - 將掃描器權杖儲存在 CI 密碼中。
    - 提供執行掃描器的範例 CI 工作。
    - 如果團隊拒絕 Sonar，請在專案 README 中註明並繼續。
  - 如果 Sonar 綁定到專案：
    - 使用 Sonar 作為可操作問題的主要來源。
    - 在補救指南中參考 Sonar 規則金鑰。
  - 如果 Sonar 不可用：
    - 執行最多 3 次疑難排解檢查：
      1. 驗證專案綁定和權杖。
      2. 確保 SonarScanner 在 CI 中執行。
      3. 確認 SonarLint 已安裝並組態。
    - 如果在 3 次嘗試後仍然失敗：
      - 啟用 SpotBugs、PMD 或 Checkstyle 作為 CI 備用。
      - 開啟一個簡短的追蹤器問題，記錄阻礙和後續步驟。
- 如果使用者拒絕靜態分析工具或希望在沒有它們的情況下繼續，請繼續實作下面概述的最佳實踐、錯誤模式和程式碼異味預防指南。
- 在開發過程中主動處理程式碼異味，而不是累積技術債務。
- 在重構已識別的問題時，專注於可讀性、可維護性和效能。
- 使用 IDE / 程式碼編輯器報告的警告和建議，以便在開發早期發現常見模式。

## 最佳實踐

- **記錄**：對於主要用於儲存資料的類別 (例如 DTO、不可變資料結構)，**應使用 Java 記錄而不是傳統類別**。
- **模式匹配**：利用 `instanceof` 和 `switch` 表達式的模式匹配來簡化條件邏輯和型別轉換。
- **型別推斷**：使用 `var` 進行局部變數宣告以提高可讀性，但僅限於當型別從表達式的右側明確清晰時。
- **不可變性**：偏愛不可變物件。盡可能將類別和欄位設為 `final`。對於固定資料，使用 `List.of()`/`Map.of()` 中的集合。使用 `Stream.toList()` 建立不可變列表。
- **串流和 Lambda**：使用 Streams API 和 Lambda 表達式進行集合處理。採用方法參考 (例如 `stream.map(Foo::toBar)`)。
- **Null 處理**：避免回傳或接受 `null`。對於可能不存在的值，使用 `Optional<T>` 和 `Objects` 工具方法，例如 `equals()` 和 `requireNonNull()`。

### 命名約定

- 遵循 Google 的 Java 風格指南：
  - `UpperCamelCase` 用於類別和介面名稱。
  - `lowerCamelCase` 用於方法和變數名稱。
  - `UPPER_SNAKE_CASE` 用於常數。
  - `lowercase` 用於套件名稱。
- 類別使用名詞 (`UserService`)，方法使用動詞 (`getUserById`)。
- 避免縮寫和匈牙利命名法。

### 常見錯誤模式

以下是簡潔、易於理解的規則，無論您使用哪種靜態分析工具，都可以應用這些規則。如果您執行 Sonar/SonarLint，IDE 將顯示匹配的規則和位置 — 首選直接 Sonar 連線，並應覆蓋此規則集。

- 資源管理 — 始終關閉資源 (檔案、通訊端、串流)。盡可能使用 try-with-resources，以便自動關閉資源。
- 相等性檢查 — 對於非基本型別，使用 `.equals()` 或 `Objects.equals(...)` 比較物件相等性，而不是 `==`；這可以避免參考相等性錯誤。
- 冗餘轉換 — 移除不必要的轉換；首選正確的泛型型別，並盡可能讓編譯器推斷型別。
- 可達條件 — 避免始終為 true 或 false 的條件表達式；它們表示錯誤或死程式碼，應予以糾正。

對於確實使用 Sonar 或 SonarLint 的貢獻者：IDE/掃描將顯示特定的規則金鑰 (例如，S2095 用於資源洩漏) 和受影響的檔案/行。使用該資訊導航到確切位置，然後應用建議的補救措施。

### 常見程式碼異味

這些模式是為人類設計的；它們可以清晰地映射到 Sonar、SpotBugs、PMD 或 Checkstyle 中的檢查，但不需要這些工具才能有用。

- 參數計數 — 保持方法參數列表簡短。如果一個方法需要許多參數，請考慮將其分組到值物件中或使用建構器模式。
- 方法大小 — 保持方法專注且小巧。提取輔助方法以提高可讀性和可測試性。
- 認知複雜度 — 透過提取方法、使用多型或應用策略模式來減少巢狀條件和大量分支。
- 重複的文字 — 將重複的字串和數字提取到命名常數或列舉中，以減少錯誤並簡化變更。
- 死程式碼 — 移除未使用的變數和賦值。它們會混淆讀者並可能隱藏錯誤。
- 魔術數字 — 將數字文字替換為解釋意圖的命名常數 (例如 MAX_RETRIES)。

如果您執行 Sonar 或 SonarLint 等靜態分析器 — 首選直接 Sonar 連線，並應覆蓋此規則集。Sonar 規則金鑰對於自動化和抑制很有用，但在日常開發人員指南中並非必需。

## 建構和驗證

- 新增或修改程式碼後，驗證專案是否繼續成功建構。
- 如果專案使用 Maven，請執行 `mvn clean install`。
- 如果專案使用 Gradle，請執行 `./gradlew build` (或在 Windows 上執行 `gradlew.bat build`)。
- 確保所有測試作為建構的一部分通過。
