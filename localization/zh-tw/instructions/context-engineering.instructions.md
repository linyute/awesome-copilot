---
description: '透過更好的上下文管理來結構化程式碼與專案，以最大化 GitHub Copilot 成效的指引'
applyTo: '**'
---

# 上下文工程

協助 GitHub Copilot 理解您的程式碼庫並提供更好建議的原則。

## 專案結構

- **使用具描述性的檔案路徑**：`src/auth/middleware.ts` > `src/utils/m.ts`。Copilot 使用路徑來推斷意圖。
- **同處配置 (Colocate) 相關程式碼**：將元件、測試、型別和 Hook 放在一起。一個搜尋模式應該能找到所有相關內容。
- **從 index 檔案匯出公開 API**：匯出的內容是契約；未匯出的則是內部的。這有助於 Copilot 理解邊界。

## 程式碼模式

- **偏好明確型別而非推斷**：型別註解即是上下文。`function getUser(id: string): Promise<User>` 比 `function getUser(id)` 告訴 Copilot 更多資訊。
- **使用語義化名稱**：`activeAdultUsers` > `x`。自我文件化的程式碼是 AI 可讀的程式碼。
- **定義常數**：`MAX_RETRY_ATTEMPTS = 3` > 魔法數字 `3`。具名數值帶有意義。

## 與 Copilot 協作

- **將相關檔案保持在分頁中開啟**：Copilot 將開啟的分頁視為上下文信號。正在處理驗證嗎？開啟驗證相關檔案。
- **有目的地定位游標**：Copilot 會優先考慮游標附近的程式碼。將游標放在上下文重要的地方。
- **對複雜任務使用 Copilot Chat**：內嵌補全 (Inline completions) 的上下文極少。Chat 模式可檢視更多檔案。

## 上下文提示

- **新增 COPILOT.md 檔案**：記錄 Copilot 應遵循的架構決策、模式與慣例。
- **使用策略性註釋**：在複雜模組的頂部，簡要描述流程或用途。
- **明確引用模式**：「遵循與 `src/api/users.ts` 相同的模式」給予 Copilot 一個具體的範例。

## 多檔案變更

- **先描述範圍**：在要求變更前告訴 Copilot 涉及的所有檔案。「我需要更新 User 模型、API 端點與測試。」
- **漸進式工作**：一次一個檔案，並驗證每個變更。不要一次要求所有內容。
- **確認理解程度**：在進行複雜重構前詢問「你需要檢視哪些檔案？」。

## 當 Copilot 遇到困難時

- **缺失上下文**：在分頁中開啟相關檔案，或明確貼上程式碼片段。
- **過時建議**：Copilot 可能沒看到最近的變更。重新開啟檔案或重新啟動對話。
- **通用答案**：更加具體。新增約束、提及框架、引用現有程式碼。
