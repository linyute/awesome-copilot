---
description: 'Shell 程式碼撰寫的最佳實踐和慣例，適用於 bash、sh、zsh 和其他 shell'
applyTo: '**/*.sh'
---

# Shell 程式碼撰寫指南

撰寫乾淨、安全且可維護的 shell 程式碼的說明，適用於 bash、sh、zsh 和其他 shell。

## 通用原則

- 建立 乾淨、簡潔和簡要的程式碼
- 確保程式碼易於閱讀和理解
- 在有助於理解程式碼運作方式的地方新增註釋
- 建立 簡潔和簡單的 echo 輸出以提供執行狀態
- 避免不必要的 echo 輸出和過多的日誌記錄
- 在可用時使用 shellcheck 進行靜態分析
- 假設程式碼用於自動化和測試，而不是生產系統，除非另有說明
- 優先使用安全擴展：雙引號變數引用 (`"$var"`)，使用 `${var}` 增加清晰度，並避免 `eval`
- 當可移植性要求允許時，使用現代 Bash 功能 (`[[ ]]`、`local`、陣列)；僅在需要時才回退到 POSIX 結構
- 選擇可靠的解析器處理結構化資料，而不是臨時的文字處理

## 錯誤處理與安全性

- 始終啟用 `set -euo pipefail` 以在錯誤時快速失敗，捕獲未設定的變數，並顯示管道失敗
- 在執行前驗證所有必需的參數
- 提供清晰且帶有上下文的錯誤訊息
- 使用 `trap` 在程式碼終止時清理臨時資源或處理意外退出
- 使用 `readonly` (或 `declare -r`) 宣告不可變值以防止意外重新指派
- 使用 `mktemp` 安全地建立臨時檔案或目錄，並確保在清理處理器中將其移除

## 程式碼結構

- 以清晰的 shebang 開頭：`#!/bin/bash`，除非另有說明
- 包含一個解釋程式碼目的的標頭註釋
- 在頂部定義所有變數的預設值
- 使用函式來建立 可重複使用的程式碼區塊
- 建立 可重複使用的函式，而不是重複相似的程式碼區塊
- 保持主要的執行流程乾淨且可讀

## 使用 JSON 和 YAML

- 優先使用專用解析器 (`jq` 處理 JSON，`yq` 處理 YAML—或透過 `yq` 轉換為 JSON 後再用 `jq` 處理)，而不是使用 `grep`、`awk` 或 shell 字串分隔進行臨時文字處理
- 當 `jq`/`yq` 不可用或不適用時，選擇環境中可用的下一個最可靠的解析器，並明確說明應如何安全使用
- 驗證必需的欄位是否存在並明確處理缺少/無效的資料路徑 (例如，透過檢查 `jq` 退出狀態或使用 `// empty`)
- 引用 jq/yq 篩選器以防止 shell 擴展，並在需要純字串時優先使用 `--raw-output`
- 將解析器錯誤視為致命錯誤：與 `set -euo pipefail` 結合使用，或在使用結果之前測試命令是否成功
- 在程式碼頂部記錄解析器依賴項，如果需要 `jq`/`yq` (或替代工具) 但未安裝，則快速失敗並顯示有用的訊息

```bash
#!/bin/bash

# ============================================================================
# 程式碼說明在此
# ============================================================================

set -euo pipefail

cleanup() {
    # 移除臨時資源或根據需要執行其他清理步驟
    if [[ -n "${TEMP_DIR:-}" && -d "$TEMP_DIR" ]]; then
        rm -rf "$TEMP_DIR"
    fi
}

trap cleanup EXIT

# 預設值
RESOURCE_GROUP=""
REQUIRED_PARAM=""
OPTIONAL_PARAM="default-value"
readonly SCRIPT_NAME="$(basename "$0")"

TEMP_DIR=""

# 函式
usage() {
    echo "用法: $SCRIPT_NAME [選項]"
    echo "選項:"
    echo "  -g, --resource-group   資源群組 (必需)"
    echo "  -h, --help            顯示此說明"
    exit 0
}

validate_requirements() {
    if [[ -z "$RESOURCE_GROUP" ]]; then
        echo "錯誤: 資源群組為必需項"
        exit 1
    fi
}

main() {
    validate_requirements

    TEMP_DIR="$(mktemp -d)"
    if [[ ! -d "$TEMP_DIR" ]]; then
        echo "錯誤: 無法建立臨時目錄" >&2
        exit 1
    fi
    
    echo "============================================================================"
    echo "程式碼執行開始"
    echo "============================================================================"
    
    # 主要邏輯在此
    
    echo "============================================================================"
    echo "程式碼執行完成"
    echo "============================================================================"
}

# 解析參數
while [[ $# -gt 0 ]]; do
    case $1 in
        -g|--resource-group)
            RESOURCE_GROUP="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "未知選項: $1"
            exit 1
            ;;
    esac
done

# 執行主要函式
main "$@"

```
